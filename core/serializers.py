from rest_framework import serializers
from .models import User, Customer, Order, Payment, Meal
from django.contrib.auth.hashers import make_password # To hash the password when creating a user

# User serializer
class UserSerializer(serializers.ModelSerializer):
    password = serializers.CharField(write_only = True, required=True)
    class Meta:
        model = User
        fields = ['id', 'username', 'password', 'email', 'role', 'phone_number', 'is_staff', 'is_superuser']
        read_only_fields = ['id']

    def create(self, validated_data):
        # has password bedore saving when creating a user
        validated_data['password'] = make_password(validated_data['password'])
        return super().create(validated_data)
    
    def update(self, instance, validated_data):
        # hash password after updaying
        if 'password' in validated_data:
            validated_data['password'] = make_password(validated_data['password'])
        return super().update(instance, validated_data)

# customer serializer
class CustomerSerializer(serializers.ModelSerializer):
    total_paid = serializers.DecimalField(max_digits=10, decimal_places=2, read_only=True)
    total_unpaid = serializers.DecimalField(max_digits=10, decimal_places=2, read_only=True)
    class Meta:
        model = Customer
        fields = ['id', 'full_name', 'phone_number', 'email', 'date_created', 'total_paid', 'total_unpaid']
        read_only_fields = ['id', 'date_created']

    # Ensure that API does not send blank values for the name
    def validate_full_name(self, value):
        if not value or not value.strip():
            raise serializers.ValidationError("Fullname is required")
        return value

# meal serializer
class MealSerializer(serializers.ModelSerializer):
    class Meta:
        model = Meal
        fields = ['id', 'name', 'description', 'price', 'date_created']
        read_only_fields = ['id'] # ID is autogenerated, hence readonly
        
    def validate_name(self, value):
        if not value or not value.strip():
            raise serializers.ValidationError("Meal name is required")
        return value


# order serializer
class OrderSerializer(serializers.ModelSerializer):
    #Has foreign customer, meal and user. I don't want them to be displayed as IDs so I will nest them
    customer_name = serializers.CharField(source='customer.full_name', read_only=True)
    meal_name = serializers.CharField(source='meal.name', read_only=True)
    user_name = serializers.CharField(source='created_by.username', read_only=True)
    class Meta:
        model = Order
        fields = [
            'id',
            'customer', # FK to Customer (input as ID)
            'customer_name', # Customer name readonly
            'meal', # FK to Meal (input as ID)
            'meal_name', # Meal name readonly
            'quantity',
            'total_price', # Calculates automatically
            'date_created',
            'is_paid',
            'created_by', # Automatically set from request.user, to avoid false entries
            'user_name', # User name who created the order
        ]

        read_only_fields = ['id', 'date_created', 'total_price', 'is_paid', 'created_by']

    # Quantity validator Ensure its a positive value
    def validate_quantity(self, value):
        if value <= 0:
            raise serializers.ValidationError("Quantity must be greator than zero")
        return value
    
    def create(self, validated_data):
        # Automatically assign user of creating the order instead of manually doing it
        request = self.context.get("request")
        if request and hasattr(request, "user"):
            validated_data["created_by"] = request.user

        # Compute total_price before saving the order
        meal = validated_data["meal"]
        quantity = validated_data["quantity"]
        validated_data["total_price"] = meal.price * quantity
        return super().create(validated_data)
    
    def update(self, instance, validated_data):
        # Automatically assign user of updating the order instead of manually doing it
        request = self.context.get("request")
        if request and hasattr(request, "user"):
            validated_data["created_by"] = request.user

        # Recalculate total if meal or quanity changes
        meal = validated_data.get("meal", instance.meal)
        quantity = validated_data.get("quantity", instance.quantity)
        validated_data["total_price"] = meal.price * quantity
        return super().update(instance, validated_data)
    
# payment serializer
class PaymentSerializer(serializers.ModelSerializer):
    meal_name = serializers.CharField(source='order.meal.name', read_only=True) # Display meal ordered
    customer_name = serializers.CharField(source='order.customer.full_name', read_only=True) # Show customer who made the order
    class Meta:
        model = Payment
        fields = ['id', 'order', 'meal_name', 'amount', 'payment_method', 'payment_date', 'customer_name']
        read_only_fields = ['id', 'payment_date']

     # Payment amount should be more than zero   
    def validate_amount(self, value):
        if value <= 0:
            raise serializers.ValidationError("Payment amount must be greater than zero")
        return value
    
    # Check if order is already paid bedore accepting payment
    def validate_order(self, value):
        if value.is_paid:
            raise serializers.ValidationError("This order is already paid")
        return value
    
    # Update the is_paid field to true once a payment is done
    # We are assuming that a payment is done in full
    def create(self, validated_data):
        payment = super().create(validated_data)
        order = payment.order
        total_paid = sum(p.amount for p in order.payments.all())
        order.is_paid = total_paid >= order.total_price
        order.save(update_fields = ["is_paid"])
        return payment
    